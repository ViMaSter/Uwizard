#define EMBEDDED_DISCU // In case Crediar decides that I can't use DiscU inside this program, then removing this will easily fix that.
#define LANG_LOAD // Lets me easily prepare an un-languaged settings.bin for uploading to wiiubrew.net.
//#define DEBUG_BUILD // Allows debug stuff.

using Microsoft.VisualBasic;
using System;
using System.Diagnostics;
using System.IO;
using System.Windows.Forms;
using Uwizard.Properties;

namespace Uwizard
{
    public static class Form1
    {
        public static string getVerText(int ver)
        {
            string tver = ver.ToString();
#if DEBUG_BUILD
                return tver[0] + "." + tver[1] + "." + tver[2] + " DEBUG_BUILD";
#else
            return $"{tver[0]}.{tver[1]}.{tver[2]}";
#endif
        }

#if DEBUG_BUILD
            public static void writedebuglog(string dblog) {
                System.IO.StreamWriter sw = new System.IO.StreamWriter("uwizard_debuglog.txt", true);
                sw.WriteLine("This debug log was generated by Uwizard " + getVerText(myversion) + " :");
                sw.WriteLine();
                sw.WriteLine(dblog);
                sw.WriteLine();
                sw.WriteLine();
                sw.Close();
                sw.Dispose();
            }
#endif

        public static bool IsHex(char ch)
        {
            ch = char.ToUpper(ch);
            switch (ch)
            {
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                case 'A':
                case 'B':
                case 'C':
                case 'D':
                case 'E':
                case 'F':
                    return true;
            }

            return false;
        }

        public static byte[] hex2byte(string str)
        {
            byte[] ret = new byte[str.Length >> 1];
            for (int c = 0; c < ret.Length; c++)
            {
                if (!(IsHex(str[c * 2]) && IsHex(str[c * 2 + 1])))
                {
                    return null;
                }

                ret[c] = Convert.ToByte(str[c * 2] + str[c * 2 + 1].ToString(), 16);
            }

            return ret;
        }

        public static void runExtract(string titleKey, string commonKey, string wudPath)
        {
            byte[] tkeydu = hex2byte(titleKey);
            byte[] ckeydu = hex2byte(commonKey);

            bool haddiscu = File.Exists("DiscU.exe");

            File.WriteAllBytes("ckey.bin", ckeydu);
            File.WriteAllBytes("tkey.bin", tkeydu);

            /*System.IO.StreamWriter sw = new System.IO.StreamWriter("ckey.bin");
            sw.BaseStream.Write(ckeydu, 0, ckeydu.Length);
            sw.Close();
            sw.Dispose();

            sw = new System.IO.StreamWriter("tkey.bin");
            sw.BaseStream.Write(tkeydu, 0, tkeydu.Length);
            sw.Close();
            sw.Dispose();//*/


#if EMBEDDED_DISCU
            if (!haddiscu)
            {
                gzip.decompress(Resources.DiscU, "DiscU.exe");
                gzip.decompress(Resources.libeay32, "libeay32.dll");
            }
#endif

            Process discu = new Process();
            discu.StartInfo.FileName = $"{Environment.CurrentDirectory}\\DiscU.exe";
            discu.StartInfo.Arguments = $"\"{Environment.CurrentDirectory}\\tkey.bin\" \"{wudPath}\" \"{Environment.CurrentDirectory}\\ckey.bin\"";
            discu.StartInfo.WorkingDirectory = Environment.CurrentDirectory;
            //msgbox(discu.StartInfo.Arguments);

            discu.StartInfo.RedirectStandardInput = true;
            discu.StartInfo.RedirectStandardOutput = true;
            discu.StartInfo.RedirectStandardError = true;
            discu.StartInfo.CreateNoWindow = true;
            discu.StartInfo.UseShellExecute = false;

            discu.Start();
            //string line;
            while (!discu.StandardOutput.EndOfStream)
            {
                Console.WriteLine(discu.StandardOutput.ReadLine());
                Application.DoEvents();
            }

            discu.WaitForExit();
            discu.Dispose();

            if (File.Exists("tkey.bin"))
            {
                File.Delete("tkey.bin");
            }

            if (File.Exists("ckey.bin"))
            {
                File.Delete("ckey.bin");
            }
#if EMBEDDED_DISCU
            if (!haddiscu)
            {
                if (File.Exists("DiscU.exe"))
                {
                    File.Delete("DiscU.exe");
                }

                if (File.Exists("libeay32.dll"))
                {
                    File.Delete("libeay32.dll");
                }
            }
#endif
        }

        public static int lastnumchannels = -1;
        public static int myversion = 115;

        public static bool convertbfstm(string infile, string outfile, bool exchannels)
        {
            if (exchannels)
            {
                gzip.decompress(Resources.bfstm_decoder, "bfstm_decoder.exe");
                gzip.decompress(Resources.libg7221_decode, "libg7221_decode.dll");
                gzip.decompress(Resources.libmpg123_0, "libmpg123-0.dll");
                gzip.decompress(Resources.libvorbis, "libvorbis.dll");

                Process bfstm_decoder_p = new Process();

                bfstm_decoder_p.StartInfo.UseShellExecute = false;
                bfstm_decoder_p.StartInfo.CreateNoWindow = true;
                bfstm_decoder_p.StartInfo.RedirectStandardOutput = true;

                bfstm_decoder_p.StartInfo.FileName = Path.GetFileName("bfstm_decoder.exe");
                bfstm_decoder_p.StartInfo.Arguments = $"-m \"{infile}\"";
                bfstm_decoder_p.Start();

                string tmp = "";
                lastnumchannels = 1;

                while (!bfstm_decoder_p.StandardOutput.EndOfStream)
                {
                    tmp = bfstm_decoder_p.StandardOutput.ReadLine();
                    if (Strings.Left(tmp, "channels: ".Length) == "channels: ")
                    {
                        lastnumchannels = int.Parse(Strings.Right(tmp, tmp.Length - "channels: ".Length)) / 2;
                        break;
                    }
                }

                bfstm_decoder_p.WaitForExit();
                bfstm_decoder_p.StartInfo.RedirectStandardOutput = false;

#if DEBUG_BUILD
                    bfstm_decoder_p.StartInfo.CreateNoWindow = false;
                    bfstm_decoder_p.StartInfo.UseShellExecute = true;
#endif

                string ofwo = $"{Path.GetDirectoryName(outfile)}/{Path.GetFileNameWithoutExtension(outfile)}";
                string ofex = Path.GetExtension(outfile);
                string tfn;

                for (int c = 0; c < lastnumchannels; c++)
                {
                    tfn = $"{ofwo}_channel_{(c + 1)}{ofex}";
                    if (File.Exists(tfn))
                    {
                        File.Delete(tfn);
                    }

                    bfstm_decoder_p.StartInfo.Arguments = $"-2 {c} -o \"{tfn}\" \"{infile}\"";
                    bfstm_decoder_p.Start();
                    bfstm_decoder_p.WaitForExit();
                }

                bfstm_decoder_p.Dispose();

                File.Delete("bfstm_decoder.exe");
                File.Delete("libg7221_decode.dll");
                File.Delete("libmpg123-0.dll");
                File.Delete("libvorbis.dll");

                return true;
            }

            return convertbfstm(infile, outfile);
        }

        public static bool convertbfstm(string infile, string outfile)
        {
            gzip.decompress(Resources.bfstm_decoder, "bfstm_decoder.exe");
            gzip.decompress(Resources.libg7221_decode, "libg7221_decode.dll");
            gzip.decompress(Resources.libmpg123_0, "libmpg123-0.dll");
            gzip.decompress(Resources.libvorbis, "libvorbis.dll");

            if (File.Exists(outfile))
            {
                File.Delete(outfile);
            }

            Process bfstm_decoder_p = new Process();
#if DEBUG_BUILD
#else
            bfstm_decoder_p.StartInfo.CreateNoWindow = true;
            bfstm_decoder_p.StartInfo.UseShellExecute = false;
#endif
            bfstm_decoder_p.StartInfo.FileName = Path.GetFileName("bfstm_decoder.exe");
            bfstm_decoder_p.StartInfo.Arguments = $"-o \"{outfile}\" \"{infile}\"";
            bfstm_decoder_p.Start();
            bfstm_decoder_p.WaitForExit();
            bfstm_decoder_p.Dispose();

            File.Delete("bfstm_decoder.exe");
            File.Delete("libg7221_decode.dll");
            File.Delete("libmpg123-0.dll");
            File.Delete("libvorbis.dll");

            return File.Exists(outfile);
        }

        public static bool convertwav2mp3(string infile, string outfile)
        {
            gzip.decompress(Resources.mp3enc, "mp3enc.exe");

            string tof = Path.GetTempFileName();
            File.Delete(tof);

            Process bfstm_decoder_p = new Process();
#if DEBUG_BUILD
#else
            bfstm_decoder_p.StartInfo.CreateNoWindow = true;
            bfstm_decoder_p.StartInfo.UseShellExecute = false;
#endif
            bfstm_decoder_p.StartInfo.FileName = Path.GetFileName("mp3enc.exe");
            bfstm_decoder_p.StartInfo.Arguments = $"-V 5 \"{infile}\" \"{tof}";
            bfstm_decoder_p.Start();
            bfstm_decoder_p.WaitForExit();
            bfstm_decoder_p.Dispose();

            File.Delete("mp3enc.exe");

            if (File.Exists(tof))
            {
                byte[] newmp3 = File.ReadAllBytes(tof);

                for (int c = 3; c < newmp3.Length; c++)
                {
                    if (newmp3[c - 3] == 'L' && newmp3[c - 2] == 'A' && newmp3[c - 1] == 'M' && newmp3[c] == 'E')
                    {
                        newmp3[c - 3] = (byte)'U';
                        newmp3[c - 2] = (byte)'W';
                        newmp3[c - 1] = (byte)'I';
                        newmp3[c] = (byte)'Z';
                        newmp3[c + 1] = (byte)myversion.ToString()[0];
                        newmp3[c + 2] = (byte)'.';
                        newmp3[c + 3] = (byte)myversion.ToString()[1];
                        newmp3[c + 4] = (byte)'.';
                        newmp3[c + 5] = (byte)myversion.ToString()[2];
                    }
                }

                if (File.Exists(outfile))
                {
                    File.Delete(outfile);
                }

                File.WriteAllBytes(outfile, newmp3);
                File.Delete(tof);

                return true;
            }

            return false;
        }

        public static bool extractszs(string infile, string outfile)
        {
            gzip.decompress(Resources.yaz0dec, "yaz0dec.exe");
            Process yaz0dec = new Process();
            yaz0dec.StartInfo.Arguments = $"\"{infile}\"";
            yaz0dec.StartInfo.FileName = Path.GetFullPath("yaz0dec.exe");
#if DEBUG_BUILD
#else
            yaz0dec.StartInfo.CreateNoWindow = true;
            yaz0dec.StartInfo.UseShellExecute = false;
#endif
            yaz0dec.Start();
            yaz0dec.WaitForExit();
            File.Delete("yaz0dec.exe");
            if (!File.Exists($"{infile} 0.rarc"))
            {
                return false;
            }

            File.Move($"{infile} 0.rarc", outfile);
            return true;
        }

        public static bool packszs(string infile, string outfile)
        {
            gzip.decompress(Resources.yaz0enc, "yaz0enc.exe");
            Process yaz0enc = new Process();
            yaz0enc.StartInfo.Arguments = $"\"{infile}\"";
            yaz0enc.StartInfo.FileName = Path.GetFullPath("yaz0enc.exe");
#if DEBUG_BUILD
#else
            yaz0enc.StartInfo.CreateNoWindow = true;
            yaz0enc.StartInfo.UseShellExecute = false;
#endif
            yaz0enc.Start();
            yaz0enc.WaitForExit();
            File.Delete("yaz0enc.exe");
            if (!File.Exists($"{infile}.yaz0"))
            {
                return false;
            }

            File.Move($"{infile}.yaz0", outfile);
            return true;
        }
    }
}